<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>AsteriaMon Web – 2 Geräte Koop</title>
  <script src="https://unpkg.com/peerjs@1.5.5/dist/peerjs.min.js"></script>
  <style>
    :root { --bg:#0b0f14; --text:#e8eef7; --muted:#9aa7b6; --danger:#ff5d7a; --ok:#5dff9b; }
    * { box-sizing:border-box; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    body { margin:0; background:radial-gradient(1200px 600px at 30% 10%, #15203a 0%, var(--bg) 55%); color:var(--text); }
    .wrap { display:grid; gap:12px; padding:12px; max-width: 1200px; margin: 0 auto; }
    header { display:flex; gap:12px; align-items:center; justify-content:space-between; padding:12px;
      background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.08); border-radius:16px; }
    header h1 { font-size:16px; margin:0; }
    header .sub { font-size:12px; color:var(--muted); }
    .row { display:grid; grid-template-columns: 1fr 380px; gap:12px; }
    @media (max-width: 980px){ .row { grid-template-columns: 1fr; } }
    .card { background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.08); border-radius:16px; overflow:hidden; }
    .hd { display:flex; align-items:center; justify-content:space-between; padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.08); background:rgba(0,0,0,.18); }
    .bd { padding:12px; }
    .btnbar { display:flex; flex-wrap:wrap; gap:8px; }
    button { border:1px solid rgba(255,255,255,.12); background:rgba(255,255,255,.06); color:var(--text);
      padding:8px 10px; border-radius:12px; cursor:pointer; font-weight:600; font-size:12px; }
    button.primary { background:rgba(93,214,255,.14); border-color:rgba(93,214,255,.35); }
    button.danger { background:rgba(255,93,122,.14); border-color:rgba(255,93,122,.35); }
    button.ok { background:rgba(93,255,155,.14); border-color:rgba(93,255,155,.35); }
    .pill { display:inline-flex; font-size:12px; color:var(--muted); padding:6px 10px; border:1px solid rgba(255,255,255,.10);
      border-radius:999px; background:rgba(0,0,0,.2); }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    canvas { width:100%; height:auto; display:block; background:#0b0f14; }
    .log { max-height: 260px; overflow:auto; padding:10px; border-radius:12px; background:rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.10); font-size:12px; }
    .log div { margin-bottom:6px; color:var(--muted); }
    .log div strong { color:var(--text); }
    .kv { display:grid; grid-template-columns: 120px 1fr; gap:6px 10px; font-size:12px; color:var(--muted); }
    .kv b { color:var(--text); }
    .hr { height:1px; background:rgba(255,255,255,.08); margin:10px 0; }
    .small { font-size:12px; color:var(--muted); line-height:1.45; }
    .overlay { position:fixed; inset:0; display:none; place-items:center; background:rgba(0,0,0,.55); backdrop-filter: blur(6px); padding:12px; }
    .overlay.show { display:grid; }
    .modal { width:min(820px, 100%); border-radius:18px; border:1px solid rgba(255,255,255,.12);
      background:linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.03)); overflow:hidden; }
    .mh { padding:12px; display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid rgba(255,255,255,.10); }
    .mb { padding:12px; }
    textarea, input { width:100%; border-radius:12px; padding:10px; color:var(--text); background:rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.12); font-size:12px; }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div>
      <h1>AsteriaMon Web – Koop auf 2 Geräten</h1>
      <div class="sub">2 Geräte im selben Bereich • P2P (PeerJS/WebRTC) • Speichern lokal • Koop-Trainerkampf (Demo)</div>
    </div>
    <div class="btnbar">
      <button class="primary" id="btnSave">Save</button>
      <button id="btnLoad">Load</button>
      <button class="danger" id="btnReset">Reset</button>
      <button id="btnHelp">Controls</button>
    </div>
  </header>

  <div class="row">
    <div class="card">
      <div class="hd"><b>Spiel</b><span class="pill" id="statusPill">Offline</span></div>
      <div class="bd">
        <canvas id="game" width="960" height="540"></canvas>
        <div class="small" style="margin-top:10px">Gras = Begegnungen (Host). NPC „Trainer Kael“ kann Co-op Battle starten.</div>
      </div>
    </div>

    <div class="card">
      <div class="hd"><b>Multiplayer & Party</b></div>
      <div class="bd">
        <div class="kv" id="info"></div>
        <div class="hr"></div>

        <div class="small"><b>Multiplayer</b></div>
        <div class="btnbar" style="margin-top:8px">
          <button class="primary" id="btnHost">Host (Create Room)</button>
          <button id="btnJoin">Join Room</button>
          <button id="btnDisconnect">Disconnect</button>
        </div>

        <div class="small" style="margin-top:10px">
          <div><b>Room Code:</b> <span class="mono" id="roomCode">—</span></div>
          <div style="margin-top:6px"><b>Join Code:</b></div>
          <input id="joinCode" class="mono" placeholder="Paste host room code here..." />
          <div class="small" style="margin-top:8px">Tipp: WLAN ist meist zuverlässiger als mobile Daten.</div>
        </div>

        <div class="hr"></div>
        <div class="btnbar">
          <button id="btnBag">Bag</button>
          <button id="btnParty">Party</button>
        </div>

        <div class="hr"></div>
        <div class="log" id="log"></div>
      </div>
    </div>
  </div>
</div>

<div class="overlay" id="overlay">
  <div class="modal">
    <div class="mh"><b id="modalTitle">Modal</b><button id="modalClose">Close</button></div>
    <div class="mb" id="modalBody"></div>
  </div>
</div>

<script>
(() => {
  // NOTE: This is a single-file demo. Host is authoritative; Guest sends inputs.
  // Uses PeerJS client library from unpkg.
  const SPECIES = {
    Sproutle: { name:"Sproutle", type:"Leaf", baseHP:22, baseATK:9, baseDEF:8, color:"#62d96b" },
    Emberkit: { name:"Emberkit", type:"Fire", baseHP:20, baseATK:10, baseDEF:7, color:"#ff7a5d" },
    Glimmfin: { name:"Glimmfin", type:"Aqua", baseHP:21, baseATK:9, baseDEF:8, color:"#5dd6ff" },
    Stonepup: { name:"Stonepup", type:"Rock", baseHP:24, baseATK:8, baseDEF:10, color:"#c7b299" },
    Buzzlet:  { name:"Buzzlet", type:"Spark", baseHP:18, baseATK:11, baseDEF:6, color:"#ffd35d" },
    Shadeowl: { name:"Shadeowl", type:"Shadow", baseHP:19, baseATK:10, baseDEF:7, color:"#b57dff" },
  };
  const MOVES = {
    Tackle:{name:"Tackle",power:8,type:"Neutral",acc:.95},
    LeafCut:{name:"LeafCut",power:10,type:"Leaf",acc:.92},
    Ember:{name:"Ember",power:10,type:"Fire",acc:.92},
    SplashBolt:{name:"SplashBolt",power:10,type:"Aqua",acc:.92},
    PebbleHit:{name:"PebbleHit",power:9,type:"Rock",acc:.93},
    ZapNibble:{name:"ZapNibble",power:11,type:"Spark",acc:.88},
    NightPeck:{name:"NightPeck",power:11,type:"Shadow",acc:.88},
  };
  const TYPE_MULT = {
    Leaf:{Aqua:1.3,Rock:1.2,Fire:.7,Leaf:.9,Shadow:1,Spark:1,Neutral:1},
    Fire:{Leaf:1.3,Rock:.7,Aqua:.7,Fire:.9,Shadow:1,Spark:1,Neutral:1},
    Aqua:{Fire:1.3,Rock:1.2,Leaf:.7,Aqua:.9,Shadow:1,Spark:.8,Neutral:1},
    Rock:{Fire:1.2,Spark:1.1,Leaf:.8,Aqua:.8,Rock:.9,Shadow:1,Neutral:1},
    Spark:{Aqua:1.2,Shadow:1,Leaf:1,Fire:1,Rock:.9,Spark:.9,Neutral:1},
    Shadow:{Leaf:1,Fire:1,Aqua:1,Rock:1,Spark:1,Shadow:.9,Neutral:1},
    Neutral:{Leaf:1,Fire:1,Aqua:1,Rock:1,Spark:1,Shadow:1,Neutral:1},
  };

  const MAP_W=48, MAP_H=28, TILE=32;
  const map = (() => {
    const g = Array.from({length:MAP_H},()=>Array.from({length:MAP_W},()=>0));
    for (let y=0;y<MAP_H;y++) for (let x=0;x<MAP_W;x++) if(x===0||y===0||x===MAP_W-1||y===MAP_H-1) g[y][x]=1;
    for (let x=6;x<20;x++) g[8][x]=1;
    for (let y=8;y<16;y++) g[y][6]=1, g[y][19]=1;
    g[16][6]=1; g[16][19]=1; g[8][12]=0;
    for (let y=18;y<26;y++) for (let x=8;x<40;x++) if((x+y)%2===0) g[y][x]=2;
    for (let y=20;y<24;y++) for (let x=4;x<8;x++) g[y][x]=3;
    return g;
  })();

  function randId(){ return Math.random().toString(16).slice(2)+"-"+Math.random().toString(16).slice(2); }
  function defaultMovesFor(id){
    switch(id){
      case "Sproutle": return ["Tackle","LeafCut"];
      case "Emberkit": return ["Tackle","Ember"];
      case "Glimmfin": return ["Tackle","SplashBolt"];
      case "Stonepup": return ["Tackle","PebbleHit"];
      case "Buzzlet": return ["Tackle","ZapNibble"];
      case "Shadeowl": return ["Tackle","NightPeck"];
      default: return ["Tackle"];
    }
  }
  function makeMon(speciesId, level=5){
    const s = SPECIES[speciesId];
    const hp = s.baseHP + level*2;
    return { id:randId(), speciesId, name:s.name, type:s.type, level, maxHP:hp, hp, atk:s.baseATK+Math.floor(level*1.2), def:s.baseDEF+Math.floor(level*1.0), moves:defaultMovesFor(speciesId) };
  }

  const NPCS = [
    { id:"elder", x:10, y:12, kind:"talk", name:"Elder Mira",
      text:["Willkommen in Asteria!","Der Host kann Co-op Battles starten."]},
    { id:"kael", x:14, y:12, kind:"trainer", name:"Trainer Kael",
      text:["Hey! Lust auf ein Match?","Wenn ihr verbunden seid: Co-op!"],
      trainerTeam:[ makeMon("Stonepup",5), makeMon("Buzzlet",5) ]
    },
  ];

  const SAVE_KEY="asteriamon_web_mp_v1";
  const state = {
    mode:"overworld",
    role:"offline", roomCode:null, connected:false,
    player1:{x:12,y:15,dir:"down",color:"#5dd6ff",name:"P1"},
    player2:{x:13,y:15,dir:"down",color:"#ffd35d",name:"P2"},
    coins:120,
    party1:[ makeMon("Sproutle",5) ],
    party2:[ makeMon("Emberkit",5) ],
    battle:null, flags:{}
  };

  const $ = (s)=>document.querySelector(s);
  const logEl=$("#log"), infoEl=$("#info"), statusPill=$("#statusPill"), roomCodeEl=$("#roomCode");
  const overlay=$("#overlay"), modalTitle=$("#modalTitle"), modalBody=$("#modalBody");
  let modalLockClose=false;

  function escapeHtml(s){ return String(s).replace(/[&<>"']/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
  function log(msg,strong=false){ const d=document.createElement("div"); d.innerHTML=strong?`<strong>${escapeHtml(msg)}</strong>`:escapeHtml(msg); logEl.prepend(d); }
  function setStatus(t){ statusPill.textContent=t; }
  function renderInfo(){
    const p1=state.party1[0], p2=state.party2[0];
    infoEl.innerHTML = `
      <b>Role</b><div>${state.role}</div>
      <b>Connected</b><div>${state.connected?"yes":"no"}</div>
      <b>Room</b><div class="mono">${state.roomCode||"—"}</div>
      <b>P1</b><div>${p1.name} Lv ${p1.level} • HP ${p1.hp}/${p1.maxHP}</div>
      <b>P2</b><div>${p2.name} Lv ${p2.level} • HP ${p2.hp}/${p2.maxHP}</div>
    `;
    roomCodeEl.textContent = state.roomCode || "—";
  }
  function openModal(title, bodyEl, opts={}){
    modalTitle.textContent=title; modalBody.innerHTML=""; modalBody.appendChild(bodyEl);
    modalLockClose=!!opts.lockClose; overlay.classList.add("show");
  }
  function closeModal(force=false){
    if(modalLockClose && !force) return;
    overlay.classList.remove("show"); modalBody.innerHTML=""; modalLockClose=false;
  }
  $("#modalClose").onclick=()=>closeModal();
  overlay.addEventListener("click",(e)=>{ if(e.target===overlay) closeModal(); });

  function save(){ localStorage.setItem(SAVE_KEY, JSON.stringify(structuredClone(state))); log("Saved (local).",true); }
  function load(){
    const raw=localStorage.getItem(SAVE_KEY); if(!raw){ log("No save found."); return; }
    const role=state.role, connected=state.connected, roomCode=state.roomCode;
    const data=JSON.parse(raw); Object.assign(state,data);
    state.role=role; state.connected=connected; state.roomCode=roomCode;
    state.mode="overworld"; state.battle=null;
    renderInfo(); log("Loaded.",true);
  }
  function reset(){ localStorage.removeItem(SAVE_KEY); location.reload(); }

  // Input
  const keys=new Set(); window.addEventListener("keydown",(e)=>{ keys.add(e.code); if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.code)) e.preventDefault(); });
  window.addEventListener("keyup",(e)=>keys.delete(e.code));
  const pressed=new Set();
  function consumePress(code){ if(keys.has(code)&&!pressed.has(code)){ pressed.add(code); return true; } if(!keys.has(code)&&pressed.has(code)) pressed.delete(code); return false; }
  function isBlocked(x,y){ if(x<0||y<0||x>=MAP_W||y>=MAP_H) return true; const t=map[y][x]; return t===1||t===3; }
  function dirFrom(dx,dy){ if(dx===1) return "right"; if(dx===-1) return "left"; if(dy===1) return "down"; if(dy===-1) return "up"; return "down"; }
  function move(p,dx,dy){ const nx=p.x+dx, ny=p.y+dy; if(!isBlocked(nx,ny)){ p.x=nx; p.y=ny; p.dir=dirFrom(dx,dy); return true; } p.dir=dirFrom(dx,dy); return false; }
  function tileAt(x,y){ if(x<0||y<0||x>=MAP_W||y>=MAP_H) return 1; return map[y][x]; }
  function frontTile(p){ if(p.dir==="up") return {x:p.x,y:p.y-1}; if(p.dir==="down") return {x:p.x,y:p.y+1}; if(p.dir==="left") return {x:p.x-1,y:p.y}; return {x:p.x+1,y:p.y}; }
  function npcAt(x,y){ return NPCS.find(n=>n.x===x&&n.y===y); }

  // Networking
  let peer=null, conn=null, lastNetTick=0;

  function netSend(o){ try{ if(conn&&conn.open) conn.send(o); }catch{} }
  function closeNet(){
    try{ if(conn) conn.close(); }catch{}
    try{ if(peer) peer.destroy(); }catch{}
    peer=null; conn=null;
    state.connected=false; state.role="offline"; state.roomCode=null;
    setStatus("Offline"); renderInfo(); log("Disconnected.",true);
  }

  function startHost(){
    closeNet();
    state.role="host"; setStatus("Creating room…"); renderInfo();
    peer=new Peer();
    peer.on("open",(id)=>{ state.roomCode=id; setStatus("Host ready"); renderInfo(); log("Room created. Code: "+id,true); });
    peer.on("connection",(c)=>{ if(conn&&conn.open){ c.close(); return; } conn=c; wireConn(true); });
    peer.on("error",(e)=>{ log("Peer error: "+e.type,true); setStatus("Host error"); });
  }
  function joinRoom(code){
    closeNet();
    state.role="guest"; setStatus("Connecting…"); renderInfo();
    peer=new Peer();
    peer.on("open",(id)=>{ state.roomCode=id; renderInfo(); conn=peer.connect(code,{reliable:true}); wireConn(false); });
    peer.on("error",(e)=>{ log("Peer error: "+e.type,true); setStatus("Guest error"); });
  }
  function wireConn(isHostSide){
    conn.on("open",()=>{
      state.connected=true; setStatus(isHostSide?"Host connected":"Guest connected"); renderInfo(); log("Connected!",true);
      netSend({t:"hello", from:state.role, partyLead:(state.role==="host"?state.party1[0]:state.party2[0])});
      if(state.role==="host") broadcastState();
    });
    conn.on("data",(m)=>onNetMessage(m));
    conn.on("close",()=>closeNet());
    conn.on("error",()=>closeNet());
  }
  function sanitizeMon(m){
    try{
      if(!m||!m.speciesId||!SPECIES[m.speciesId]) return null;
      const base=makeMon(m.speciesId, Math.max(1,Math.min(99,m.level||5)));
      base.hp=Math.max(1,Math.min(base.maxHP, m.hp??base.hp));
      return base;
    }catch{return null;}
  }
  function onNetMessage(msg){
    if(!msg||typeof msg!=="object") return;
    if(msg.t==="hello"){
      if(state.role==="host" && msg.partyLead) state.party2[0]=sanitizeMon(msg.partyLead)||state.party2[0];
      if(state.role==="guest" && msg.partyLead) state.party1[0]=sanitizeMon(msg.partyLead)||state.party1[0];
      renderInfo();
      return;
    }
    if(msg.t==="state" && state.role==="guest"){
      if(msg.p1) Object.assign(state.player1,msg.p1);
      if(msg.p2) Object.assign(state.player2,msg.p2);
      if(msg.battle){
        state.battle=msg.battle; if(state.mode!=="battle"){ state.mode="battle"; openBattleUI(true); }
      } else {
        if(state.mode==="battle"){ closeModal(true); state.mode="overworld"; state.battle=null; }
      }
      return;
    }
    if(msg.t==="input" && state.role==="host"){
      if(state.mode!=="overworld") return;
      if(msg.dx||msg.dy) move(state.player2,msg.dx||0,msg.dy||0);
      if(msg.interact) interactAs(2);
      return;
    }
    if(msg.t==="battleAction" && state.role==="host"){
      if(state.battle && state.battle.turn==="p2"){ state.battle.p2Choice=msg.moveId; resolveTurnIfReady(); broadcastState(); }
      return;
    }
  }
  function broadcastState(){
    if(state.role!=="host" || !conn || !conn.open) return;
    netSend({ t:"state",
      p1:{x:state.player1.x,y:state.player1.y,dir:state.player1.dir},
      p2:{x:state.player2.x,y:state.player2.y,dir:state.player2.dir},
      battle: state.battle
    });
  }

  // Dialog / trainer choice (host starts battles)
  function startDialog(title, lines){
    state.mode="dialog";
    const body=document.createElement("div");
    body.innerHTML = `<div class="small" style="margin-bottom:10px"><b>${escapeHtml(title)}</b></div>` +
      lines.map(l=>`<div class="small" style="margin-bottom:8px">${escapeHtml(l)}</div>`).join("") +
      `<div class="hr"></div><div class="btnbar"><button class="primary" id="dlgOk">OK</button></div>`;
    openModal("Dialog", body);
    body.querySelector("#dlgOk").onclick=()=>{ closeModal(); state.mode="overworld"; };
  }

  function showTrainerChoice(trainer){
    state.mode="menu";
    const canCoop=state.connected;
    const body=document.createElement("div");
    body.innerHTML = `
      <div class="small"><b>${escapeHtml(trainer.name)}</b></div>
      <div class="small" style="margin-top:6px">${escapeHtml(trainer.text[0])}</div>
      <div class="small" style="margin-top:6px">${escapeHtml(trainer.text[1])}</div>
      <div class="hr"></div>
      <div class="btnbar">
        <button class="primary" id="soloBtn">Solo Fight</button>
        <button class="ok" id="coopBtn" ${canCoop?"":"disabled"}>Co-op Fight (2 devices)</button>
        <button id="cancelBtn">Cancel</button>
      </div>
      <div class="small" style="margin-top:10px">Co-op nur wenn Gast verbunden ist.</div>
    `;
    openModal("Trainer Battle", body);
    body.querySelector("#soloBtn").onclick=()=>{ closeModal(); startTrainerBattle(trainer,false); };
    body.querySelector("#coopBtn").onclick=()=>{ closeModal(); startTrainerBattle(trainer,true); };
    body.querySelector("#cancelBtn").onclick=()=>{ closeModal(); state.mode="overworld"; };
  }

  function interactAs(playerIndex){
    if(state.mode!=="overworld") return;
    const p = (playerIndex===1)?state.player1:state.player2;
    const ft=frontTile(p);
    const n=npcAt(ft.x,ft.y);
    if(!n){ log((playerIndex===1?"P1":"P2")+": Nothing here."); return; }
    if(n.kind==="talk"){ startDialog(n.name,n.text); if(state.role==="host") broadcastState(); }
    if(n.kind==="trainer"){
      if(state.role==="host") showTrainerChoice(n);
      else log("Nur der Host kann Trainer-Battles starten.", true);
    }
  }

  // Battles (host-authoritative, synced)
  function startTrainerBattle(trainer, coop){
    if(state.role!=="host") return;
    const team = trainer.trainerTeam.map(m=>({ ...m, id:randId() }));
    state.battle = { kind:"trainer", coop:!!coop, trainerName:trainer.name, trainerTeam:team, enemy:team[0],
      turn:"p1", msg:"Choose an action.", p1Choice:null, p2Choice:null };
    state.mode="battle";
    log(trainer.name+" challenges you!", true);
    openBattleUI(false);
    broadcastState();
  }
  function startWildBattle(){
    if(state.role!=="host") return;
    const pool=["Sproutle","Emberkit","Glimmfin","Stonepup","Buzzlet","Shadeowl"];
    const pick=pool[Math.floor(Math.random()*pool.length)];
    const lvl=4+Math.floor(Math.random()*4);
    const enemy=makeMon(pick,lvl);
    state.battle={kind:"wild",coop:false,trainerName:null,trainerTeam:null,enemy,turn:"p1",msg:"Choose an action.",p1Choice:null,p2Choice:null};
    state.mode="battle"; log("A wild "+enemy.name+" appeared!", true);
    openBattleUI(false); broadcastState();
  }
  function dmgCalc(attacker, defender, mv){
    const hit=Math.random()<mv.acc; if(!hit) return {hit:false,dmg:0,mult:1};
    const mult=(TYPE_MULT[mv.type]&&TYPE_MULT[mv.type][defender.type])?TYPE_MULT[mv.type][defender.type]:1;
    const base = mv.power + Math.floor(attacker.atk*0.6) - Math.floor(defender.def*0.35);
    const dmg = Math.max(1, Math.floor(base*mult*(0.85+Math.random()*0.3)));
    return {hit:true,dmg,mult};
  }
  function playerAttack(who, moveId){
    const b=state.battle; if(!b) return;
    const attacker = (who==="p1")?state.party1[0]:state.party2[0];
    const e=b.enemy; const mv=MOVES[moveId]||MOVES.Tackle;
    const r=dmgCalc(attacker,e,mv);
    if(!r.hit){ b.msg = attacker.name+" used "+mv.name+"… missed!"; return; }
    e.hp=Math.max(0,e.hp-r.dmg);
    b.msg = attacker.name+" used "+mv.name+" • "+r.dmg+" dmg" + (r.mult>1.05?" (effective!)":r.mult<0.95?" (not very...)":"");
  }
  function enemyAct(){
    const b=state.battle; if(!b) return;
    const e=b.enemy; const mvId=e.moves[Math.floor(Math.random()*e.moves.length)];
    const mv=MOVES[mvId]||MOVES.Tackle;
    const target = b.coop ? (Math.random()<0.5?state.party1[0]:state.party2[0]) : state.party1[0];
    const r=dmgCalc(e,target,mv);
    if(!r.hit){ b.msg=e.name+" used "+mv.name+"… missed!"; return; }
    target.hp=Math.max(0,target.hp-r.dmg);
    b.msg=e.name+" used "+mv.name+" on "+target.name+" • "+r.dmg+" dmg" + (r.mult>1.05?" (effective!)":r.mult<0.95?" (not very...)":"");
    if(target.hp<=0) b.msg += " • fainted!";
  }
  function checkBattleEnd(){
    const b=state.battle; if(!b) return false;
    const e=b.enemy;
    if(e.hp<=0){
      if(b.kind==="wild"){ endBattle(true); return true; }
      const team=b.trainerTeam; const idx=team.findIndex(m=>m.id===e.id);
      const next=idx+1;
      if(next<team.length){ b.enemy=team[next]; b.msg=e.name+" fainted. Next opponent!"; return false; }
      endBattle(true); return true;
    }
    const p1=state.party1[0], p2=state.party2[0];
    const alive1=p1.hp>0, alive2=b.coop?(p2.hp>0):true;
    if(!alive1 && !alive2){ endBattle(false); return true; }
    return false;
  }
  function endBattle(success){
    closeModal(true);
    state.mode="overworld"; state.battle=null;
    if(state.role==="host") broadcastState();
    save();
    log(success?"Battle ended.":"Defeated…", true);
  }
  function resolveTurnIfReady(){
    const b=state.battle; if(!b) return;
    if(b.turn==="p1" && !b.p1Choice) return;
    if(b.coop && b.turn==="p2" && !b.p2Choice) return;

    if(b.turn==="p1"){ playerAttack("p1", b.p1Choice); b.p1Choice=null; if(!checkBattleEnd()) advanceTurn(); }
    else if(b.turn==="p2"){ playerAttack("p2", b.p2Choice); b.p2Choice=null; if(!checkBattleEnd()) advanceTurn(); }
    else { enemyAct(); if(!checkBattleEnd()) advanceTurn(); }
  }
  function advanceTurn(){
    const b=state.battle; if(!b) return;
    if(b.coop) b.turn = (b.turn==="p1")?"p2":(b.turn==="p2")?"enemy":"p1";
    else b.turn = (b.turn==="p1")?"enemy":"p1";
    b.msg="Choose an action.";
    if(b.turn==="enemy" && state.role==="host") setTimeout(()=>{ resolveTurnIfReady(); if(state.role==="host") broadcastState(); }, 220);
  }

  function openBattleUI(netControlled){
    const b=state.battle; if(!b) return;
    const p1=state.party1[0], p2=state.party2[0], e=b.enemy;
    const body=document.createElement("div");
    body.innerHTML = `
      <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px;">
        <div class="card" style="border-radius:14px">
          <div class="hd"><b>${b.kind==="wild"?"Wild":"Trainer"} Battle</b></div>
          <div class="bd">
            <div class="small"><b>Enemy:</b> <span class="mono">${e.name}</span> • HP <span class="mono" id="ehp">${e.hp}</span>/${e.maxHP}</div>
            <div class="small" style="margin-top:8px" id="bmsg">${escapeHtml(b.msg||"")}</div>
          </div>
        </div>
        <div class="card" style="border-radius:14px">
          <div class="hd"><b>Your Side</b></div>
          <div class="bd">
            <div class="small"><b>P1:</b> ${p1.name} • HP <span class="mono" id="p1hp">${p1.hp}</span>/${p1.maxHP}</div>
            <div class="small" style="margin-top:6px"><b>P2:</b> ${b.coop?`${p2.name} • HP <span class="mono" id="p2hp">${p2.hp}</span>/${p2.maxHP}`:"—"}</div>
            <div class="hr"></div>
            <div class="small"><b>Turn:</b> <span class="mono" id="turn">${b.turn}</span> • <b>Role:</b> <span class="mono">${state.role}</span></div>
          </div>
        </div>
      </div>
      <div class="hr"></div>
      <div class="btnbar" id="actions"></div>
    `;
    openModal("Battle", body, {lockClose:true});

    function redraw(){
      if(!state.battle) return;
      const bb=state.battle;
      body.querySelector("#ehp").textContent = bb.enemy.hp;
      body.querySelector("#p1hp").textContent = state.party1[0].hp;
      const p2hp=body.querySelector("#p2hp"); if(p2hp) p2hp.textContent=state.party2[0].hp;
      body.querySelector("#turn").textContent = bb.turn;
      body.querySelector("#bmsg").textContent = bb.msg || "Choose an action.";
      renderActions();
    }
    function renderActions(){
      const bar=body.querySelector("#actions"); bar.innerHTML="";
      const bb=state.battle; if(!bb) return;

      if(bb.turn==="p1"){
        if(state.role!=="host"){ bar.appendChild(txt("Waiting for Host (P1)…")); return; }
        renderMoveButtons("p1"); return;
      }
      if(bb.turn==="p2"){
        if(!bb.coop){ bar.appendChild(txt("—")); return; }
        if(state.role!=="guest"){ bar.appendChild(txt("Waiting for Guest (P2)…")); return; }
        renderMoveButtons("p2"); return;
      }
      bar.appendChild(txt("Enemy is acting…"));
    }
    function txt(t){ const d=document.createElement("div"); d.className="small"; d.textContent=t; return d; }
    function renderMoveButtons(who){
      const mon=(who==="p1")?state.party1[0]:state.party2[0];
      mon.moves.forEach(m=>{
        const mv=MOVES[m];
        const btt=document.createElement("button"); btt.className="primary";
        btt.textContent = `${mv.name} (${mv.type})`;
        btt.onclick=()=>{
          if(state.role==="host"){
            state.battle.p1Choice=m; resolveTurnIfReady(); redraw(); broadcastState();
          } else {
            netSend({t:"battleAction", moveId:m});
            state.battle.msg="P2 selected "+mv.name+"…";
            redraw();
          }
        };
        bar.appendChild(btt);
      });
    }

    const iv=setInterval(()=>{ if(!overlay.classList.contains("show") || state.mode!=="battle"){ clearInterval(iv); return; } redraw(); }, 120);
    redraw();
  }

  // Loop
  function handleInput(){
    if(state.mode!=="overworld") return;

    if(state.role==="host" || state.role==="offline"){
      let moved=false;
      if(keys.has("ArrowUp")) moved=move(state.player1,0,-1);
      else if(keys.has("ArrowDown")) moved=move(state.player1,0,1);
      else if(keys.has("ArrowLeft")) moved=move(state.player1,-1,0);
      else if(keys.has("ArrowRight")) moved=move(state.player1,1,0);

      if(consumePress("KeyE") || consumePress("Enter")) interactAs(1);

      if(moved && state.role==="host"){
        if(tileAt(state.player1.x,state.player1.y)===2 && Math.random()<0.14) startWildBattle();
      }
    } else {
      // guest controls player2 and sends to host
      let dx=0,dy=0;
      if(keys.has("ArrowUp")) dy=-1;
      else if(keys.has("ArrowDown")) dy=1;
      else if(keys.has("ArrowLeft")) dx=-1;
      else if(keys.has("ArrowRight")) dx=1;

      if(dx||dy){
        state.player2.dir=dirFrom(dx,dy);
        netSend({t:"input", dx, dy});
      }
      if(consumePress("KeyE") || consumePress("Enter")) netSend({t:"input", interact:true});
    }

    const now=performance.now();
    if(state.role==="host" && state.connected && (now-lastNetTick)>110){ lastNetTick=now; broadcastState(); }
  }

  // Render
  const canvas=$("#game"), ctx=canvas.getContext("2d");
  function roundRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
    ctx.fill();
  }
  function drawPlayer(p, camX, camY){
    const px=p.x*TILE-camX, py=p.y*TILE-camY;
    ctx.fillStyle=p.color; roundRect(px+5,py+5,TILE-10,TILE-10,12);
    ctx.fillStyle="rgba(0,0,0,.25)";
    const fx=p.dir==="left"?px+8:p.dir==="right"?px+TILE-14:px+TILE/2-3;
    const fy=p.dir==="up"?py+8:p.dir==="down"?py+TILE-14:py+TILE/2-3;
    ctx.fillRect(fx,fy,6,6);
  }
  function draw(){
    const focus = (state.role==="guest") ? state.player2 : state.player1;
    const camX=focus.x*TILE-canvas.width/2+TILE/2;
    const camY=focus.y*TILE-canvas.height/2+TILE/2;

    ctx.fillStyle="#0b0f14"; ctx.fillRect(0,0,canvas.width,canvas.height);
    for(let y=0;y<MAP_H;y++) for(let x=0;x<MAP_W;x++){
      const px=x*TILE-camX, py=y*TILE-camY;
      if(px<-TILE||py<-TILE||px>canvas.width+TILE||py>canvas.height+TILE) continue;
      const t=map[y][x];
      if(t===0){ ctx.fillStyle="#1a2436"; ctx.fillRect(px,py,TILE,TILE); }
      else if(t===1){ ctx.fillStyle="#303b52"; ctx.fillRect(px,py,TILE,TILE); }
      else if(t===2){
        ctx.fillStyle="#1a2f24"; ctx.fillRect(px,py,TILE,TILE);
        ctx.fillStyle="rgba(98,217,107,.55)";
        for(let i=0;i<5;i++) ctx.fillRect(px+6+i*5, py+10+(i%2)*6, 2,2);
      } else if(t===3){
        ctx.fillStyle="#15314a"; ctx.fillRect(px,py,TILE,TILE);
        ctx.fillStyle="rgba(93,214,255,.25)"; ctx.fillRect(px+6,py+6,TILE-12,TILE-12);
      }
      ctx.strokeStyle="rgba(255,255,255,.04)"; ctx.strokeRect(px,py,TILE,TILE);
    }
    NPCS.forEach(n=>{ const px=n.x*TILE-camX, py=n.y*TILE-camY; ctx.fillStyle=n.kind==="trainer"?"#ff5d7a":"#9aa7b6"; roundRect(px+6,py+6,TILE-12,TILE-12,10); });
    drawPlayer(state.player1,camX,camY); drawPlayer(state.player2,camX,camY);

    // YOU label
    const me=focus;
    const lx=me.x*TILE-camX+TILE/2, ly=me.y*TILE-camY-10;
    ctx.fillStyle="rgba(0,0,0,.55)"; roundRect(lx-34,ly-18,68,16,8);
    ctx.fillStyle="rgba(255,255,255,.85)"; ctx.font="12px ui-sans-serif"; ctx.textAlign="center";
    ctx.fillText("YOU",lx,ly-6);

    requestAnimationFrame(draw);
  }

  // UI buttons
  $("#btnSave").onclick=save;
  $("#btnLoad").onclick=load;
  $("#btnReset").onclick=reset;
  $("#btnBag").onclick=()=>{
    const body=document.createElement("div");
    body.innerHTML = `<div class="small"><b>Bag</b></div><div class="hr"></div><div class="small">(Items im Battle-Demo nicht implementiert)</div>`;
    openModal("Bag", body);
  };
  $("#btnParty").onclick=()=>{
    const party=(state.role==="guest")?state.party2:state.party1;
    const body=document.createElement("div");
    body.innerHTML=`<div class="small"><b>Your Party</b></div><div class="hr"></div><div class="btnbar" id="list"></div>`;
    const list=body.querySelector("#list");
    party.forEach((m,idx)=>{
      const b=document.createElement("button"); b.className=idx===0?"primary":"";
      b.textContent=`${m.name} Lv ${m.level} • HP ${m.hp}/${m.maxHP}`;
      b.onclick=()=>{ party.splice(idx,1); party.unshift(m); save(); renderInfo(); closeModal(); log("Lead set.",true);
        if(state.connected) netSend({t:"hello", from:state.role, partyLead:party[0]});
        if(state.role==="host") broadcastState();
      };
      list.appendChild(b);
    });
    openModal("Party", body);
  };
  $("#btnHelp").onclick=()=>{
    const body=document.createElement("div");
    body.innerHTML = `
      <div class="small"><b>Controls</b></div>
      <div class="hr"></div>
      <div class="small">
        Move: Arrow Keys<br/>
        Interact: E or Enter<br/><br/>
        <b>Multiplayer</b>:<br/>
        - Gerät 1: Host → Room Code teilen<br/>
        - Gerät 2: Join → Code einfügen<br/>
        <br/>
        Hinweis: Wenn es nicht verbindet, probiert WLAN oder hostet diese Datei über HTTPS (z.B. GitHub Pages).
      </div>`;
    openModal("Controls", body);
  };
  $("#btnHost").onclick=startHost;
  $("#btnJoin").onclick=()=>{
    const code=($("#joinCode").value||"").trim();
    if(!code) return alert("Paste the host room code first.");
    joinRoom(code);
  };
  $("#btnDisconnect").onclick=closeNet;

  // Boot
  function boot(){
    setStatus("Offline");
    renderInfo();
    log("Ready. Host or Join.", true);
    draw();
    setInterval(()=>{
      handleInput();
      renderInfo();
      if(state.role==="guest" && state.battle && state.mode==="battle" && !overlay.classList.contains("show")){
        openBattleUI(true);
      }
    }, 90);
  }
  boot();
})();
</script>
</body>
</html>
